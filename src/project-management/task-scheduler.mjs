// Task Scheduler
// Handles task breakdown, dependency resolution, and scheduling
// Refactored to use shared topologicalSchedule (see docs/DUPLICATE_CODE_ANALYSIS.md â€” DUP-3)

import { TASK_STATUS, DELIVERABLE_STATUS } from './project-manifest.mjs';
import { topologicalSchedule } from '../lib/scheduling-utils.mjs';
import fs from 'fs';
import path from 'path';

/**
 * @typedef {Object} ScheduledTask
 * @property {string} id - Task ID
 * @property {string} name - Task name
 * @property {string} deliverable - Associated deliverable
 * @property {string} assignee - Assignee
 * @property {string} status - Current status
 * @property {string} priority - Priority level
 * @property {string[]} dependencies - Task IDs this depends on
 * @property {string[]} dependents - Task IDs that depend on this
 */

/**
 * @typedef {Object} ExecutionStage
 * @property {number} id - Stage number
 * @property {ScheduledTask[]} tasks - Tasks that can run in parallel
 * @property {string} description - Stage description
 */

/**
 * @typedef {Object} ExecutionPlan
 * @property {string} createdAt - Timestamp
 * @property {number} totalTasks - Total task count
 * @property {number} totalStages - Total stage count
 * @property {ExecutionStage[]} stages - Ordered execution stages
 * @property {Object} criticalPath - Critical path analysis
 */

export class TaskScheduler {
    constructor(projectManifest) {
        this.manifest = projectManifest;
    }

    // Create a task breakdown from deliverables
    async createTaskBreakdown(options = {}) {
        const {
            minTasksPerDeliverable = 2,
            defaultAssignee = '@user',
            autoGenerateDependencies = true
        } = options;

        const parsed = await this.manifest.parseManifest();
        if (!parsed) {
            return { success: false, message: 'No manifest found.' };
        }

        const deliverables = parsed.deliverables;
        if (deliverables.length === 0) {
            return { success: false, message: 'No deliverables defined. Add deliverables first.' };
        }

        const tasks = [];
        const existingTasks = parsed.tasks;

        // Generate tasks for each deliverable
        for (const deliverable of deliverables) {
            const deliverableTasks = existingTasks.filter(t => t.deliverable === deliverable.id);
            
            if (deliverableTasks.length >= minTasksPerDeliverable) {
                continue; // Already has enough tasks
            }

            // Generate minimum default tasks
            const tasksToCreate = minTasksPerDeliverable - deliverableTasks.length;
            
            for (let i = 0; i < tasksToCreate; i++) {
                const taskNum = deliverableTasks.length + i + 1;
                const taskName = this.generateTaskName(deliverable.deliverable, taskNum);
                
                const result = await this.manifest.addTask(
                    null, // Auto-generate ID
                    taskName,
                    deliverable.id,
                    deliverable.owner || defaultAssignee,
                    TASK_STATUS.TODO,
                    this.inferPriority(deliverable, taskNum)
                );
                
                tasks.push(result.id);
            }
        }

        return {
            success: true,
            message: `Created ${tasks.length} new task(s)`,
            taskIds: tasks
        };
    }

    // Generate sensible task names based on deliverable
    generateTaskName(deliverableName, taskNumber) {
        const namePatterns = {
            1: ['Plan', 'Design', 'Define'],
            2: ['Implement', 'Create', 'Build'],
            3: ['Test', 'Verify', 'Review'],
            4: ['Document', 'Finalize', 'Polish']
        };

        const patterns = namePatterns[taskNumber] || ['Work on'];
        const verb = patterns[Math.floor(Math.random() * patterns.length)];
        
        return `${verb} ${deliverableName}`;
    }

    // Infer priority from deliverable and task order
    inferPriority(deliverable, taskNumber) {
        if (taskNumber === 1) return 'High';
        if (deliverable.status === DELIVERABLE_STATUS.BLOCKED) return 'High';
        return 'Medium';
    }

    // Build dependency graph from tasks
    async buildDependencyGraph() {
        const parsed = await this.manifest.parseManifest();
        if (!parsed) return null;

        const tasks = parsed.tasks;
        const deliverables = parsed.deliverables;

        // Build a map of task dependencies
        const graph = new Map();
        const inDegree = new Map();
        const taskMap = new Map();

        for (const task of tasks) {
            taskMap.set(task.id, task);
            graph.set(task.id, []);
            inDegree.set(task.id, 0);
        }

        // Infer dependencies from deliverable dependencies
        for (const deliverable of deliverables) {
            if (!deliverable.dependencies || deliverable.dependencies === '-') continue;

            const deps = deliverable.dependencies.split(',').map(d => d.trim());
            const deliverableTasks = tasks.filter(t => t.deliverable === deliverable.id);
            
            for (const depId of deps) {
                const depTasks = tasks.filter(t => t.deliverable === depId);
                
                // Each task of this deliverable depends on completion of dependent deliverable tasks
                for (const task of deliverableTasks) {
                    for (const depTask of depTasks) {
                        if (!graph.get(depTask.id).includes(task.id)) {
                            graph.get(depTask.id).push(task.id);
                            inDegree.set(task.id, (inDegree.get(task.id) || 0) + 1);
                        }
                    }
                }
            }
        }

        // Also check for task-level dependencies within same deliverable
        // Assume tasks are ordered by creation, first task depends on nothing within deliverable
        const deliverableTaskGroups = new Map();
        for (const task of tasks) {
            if (!deliverableTaskGroups.has(task.deliverable)) {
                deliverableTaskGroups.set(task.deliverable, []);
            }
            deliverableTaskGroups.get(task.deliverable).push(task);
        }

        return {
            graph,
            inDegree,
            taskMap,
            deliverableTaskGroups
        };
    }

    // Create execution plan using topological sort
    async createExecutionPlan(options = {}) {
        const {
            numParallel = 3,
            outputFile = null,
            prioritizeHigh = true
        } = options;

        const parsed = await this.manifest.parseManifest();
        if (!parsed) {
            return { success: false, message: 'No manifest found.' };
        }

        const tasks = parsed.tasks.filter(t => 
            t.status !== TASK_STATUS.DONE && 
            t.status !== TASK_STATUS.CANCELLED
        );

        if (tasks.length === 0) {
            return { success: false, message: 'No pending tasks to schedule.' };
        }

        const depGraph = await this.buildDependencyGraph();
        if (!depGraph) {
            return { success: false, message: 'Failed to build dependency graph.' };
        }

        const { graph, taskMap } = depGraph;

        // Build dependency arrays for each task from the graph
        // The graph maps sourceId -> [targetIds], so we need to invert it
        const taskDeps = new Map();
        for (const task of tasks) {
            taskDeps.set(task.id, []);
        }
        for (const [sourceId, targets] of graph) {
            for (const targetId of targets) {
                if (taskDeps.has(targetId)) {
                    taskDeps.get(targetId).push(sourceId);
                }
            }
        }

        // Prepare items for topologicalSchedule
        const schedulableItems = tasks.map(t => ({
            ...taskMap.get(t.id) || t,
            id: t.id,
            dependencies: taskDeps.get(t.id) || [],
            status: t.status
        }));

        // Build sort function for priority
        const prioritySortFn = prioritizeHigh ? (a, b) => {
            const priorityOrder = { 'High': 0, 'Medium': 1, 'Low': 2 };
            const itemA = taskMap.get(a);
            const itemB = taskMap.get(b);
            return (priorityOrder[itemA?.priority] || 1) - (priorityOrder[itemB?.priority] || 1);
        } : null;

        // Use shared topological schedule
        const { stages, unscheduled } = topologicalSchedule(schedulableItems, {
            numParallel,
            doneStatus: TASK_STATUS.DONE,
            sortFn: prioritySortFn
        });

        // Add descriptions to stages
        for (const stage of stages) {
            stage.description = `Stage ${stage.id}: ${stage.tasks.map(t => t.task || t.name || t.id).join(', ')}`;
        }

        if (unscheduled.length > 0) {
            return {
                success: false,
                message: `Cyclic dependency detected. Unschedulable tasks: ${unscheduled.join(', ')}`
            };
        }

        // Calculate critical path (longest path through graph)
        const criticalPath = this.calculateCriticalPath(stages, graph);

        const plan = {
            createdAt: new Date().toISOString(),
            totalTasks: tasks.length,
            totalStages: stages.length,
            parallelCapacity: numParallel,
            stages,
            criticalPath
        };

        // Save plan if output file specified
        if (outputFile) {
            const planPath = path.join(this.manifest.workingDir, outputFile);
            await fs.promises.writeFile(planPath, JSON.stringify(plan, null, 2), 'utf8');
        }

        // Update manifest
        await this.manifest.addSnapshot(`Execution plan created: ${stages.length} stages, ${tasks.length} tasks`);

        return {
            success: true,
            message: `Execution plan created with ${stages.length} stages for ${tasks.length} tasks`,
            plan
        };
    }

    // Calculate critical path
    calculateCriticalPath(stages, graph) {
        // Simple critical path: longest sequence of dependent tasks
        const pathLengths = new Map();
        
        for (let i = stages.length - 1; i >= 0; i--) {
            for (const task of stages[i].tasks) {
                const dependents = graph.get(task.id) || [];
                let maxDependentLength = 0;
                
                for (const depId of dependents) {
                    if (pathLengths.has(depId)) {
                        maxDependentLength = Math.max(maxDependentLength, pathLengths.get(depId));
                    }
                }
                
                pathLengths.set(task.id, maxDependentLength + 1);
            }
        }

        // Find tasks on critical path (longest path)
        const maxLength = Math.max(...pathLengths.values());
        const criticalTasks = [];
        
        for (const [taskId, length] of pathLengths) {
            if (length === maxLength) {
                criticalTasks.push(taskId);
            }
        }

        return {
            length: maxLength,
            tasks: criticalTasks
        };
    }

    // Update task status
    async updateTaskStatus(taskId, newStatus) {
        const parsed = await this.manifest.parseManifest();
        if (!parsed) return { success: false, message: 'No manifest found.' };

        const task = parsed.tasks.find(t => t.id === taskId);
        if (!task) {
            return { success: false, message: `Task ${taskId} not found.` };
        }

        await this.manifest.addTask(
            taskId,
            task.task,
            task.deliverable,
            task.assignee,
            newStatus,
            task.priority
        );

        return {
            success: true,
            message: `Task ${taskId} status updated to ${newStatus}`
        };
    }

    // Mark task as done
    async completeTask(taskId) {
        return await this.updateTaskStatus(taskId, TASK_STATUS.DONE);
    }

    // Start a task
    async startTask(taskId) {
        return await this.updateTaskStatus(taskId, TASK_STATUS.IN_PROGRESS);
    }

    // Block a task
    async blockTask(taskId, reason = '') {
        const result = await this.updateTaskStatus(taskId, TASK_STATUS.BLOCKED);
        if (result.success && reason) {
            await this.manifest.addSnapshot(`Task ${taskId} blocked: ${reason}`);
        }
        return result;
    }

    // Get tasks by status
    async getTasksByStatus(status) {
        const parsed = await this.manifest.parseManifest();
        if (!parsed) return [];

        return parsed.tasks.filter(t => t.status === status);
    }

    // Get tasks for a deliverable
    async getTasksForDeliverable(deliverableId) {
        const parsed = await this.manifest.parseManifest();
        if (!parsed) return [];

        return parsed.tasks.filter(t => t.deliverable === deliverableId);
    }

    // Get blocked tasks with blocker info
    async getBlockedTasks() {
        const parsed = await this.manifest.parseManifest();
        if (!parsed) return [];

        const blockedTasks = parsed.tasks.filter(t => t.status === TASK_STATUS.BLOCKED);
        const depGraph = await this.buildDependencyGraph();

        return blockedTasks.map(task => {
            // Find what's blocking this task (incomplete dependencies)
            const blockers = [];
            if (depGraph) {
                for (const [sourceId, targets] of depGraph.graph) {
                    if (targets.includes(task.id)) {
                        const sourceTask = depGraph.taskMap.get(sourceId);
                        if (sourceTask && sourceTask.status !== TASK_STATUS.DONE) {
                            blockers.push(sourceId);
                        }
                    }
                }
            }

            return {
                ...task,
                blockedBy: blockers
            };
        });
    }

    // Get task burndown data for charts
    async getBurndownData() {
        const parsed = await this.manifest.parseManifest();
        if (!parsed) return null;

        const tasks = parsed.tasks;
        const total = tasks.length;
        const done = tasks.filter(t => t.status === TASK_STATUS.DONE).length;
        const inProgress = tasks.filter(t => t.status === TASK_STATUS.IN_PROGRESS).length;
        const todo = tasks.filter(t => t.status === TASK_STATUS.TODO).length;
        const blocked = tasks.filter(t => t.status === TASK_STATUS.BLOCKED).length;

        // Group by priority
        const byPriority = {
            High: tasks.filter(t => t.priority === 'High'),
            Medium: tasks.filter(t => t.priority === 'Medium'),
            Low: tasks.filter(t => t.priority === 'Low')
        };

        // Group by deliverable
        const byDeliverable = new Map();
        for (const task of tasks) {
            if (!byDeliverable.has(task.deliverable)) {
                byDeliverable.set(task.deliverable, []);
            }
            byDeliverable.get(task.deliverable).push(task);
        }

        return {
            total,
            status: { done, inProgress, todo, blocked },
            remaining: total - done,
            percentComplete: total > 0 ? Math.round((done / total) * 100) : 0,
            byPriority: {
                High: {
                    total: byPriority.High.length,
                    done: byPriority.High.filter(t => t.status === TASK_STATUS.DONE).length
                },
                Medium: {
                    total: byPriority.Medium.length,
                    done: byPriority.Medium.filter(t => t.status === TASK_STATUS.DONE).length
                },
                Low: {
                    total: byPriority.Low.length,
                    done: byPriority.Low.filter(t => t.status === TASK_STATUS.DONE).length
                }
            },
            byDeliverable: Object.fromEntries(
                [...byDeliverable.entries()].map(([delId, delTasks]) => [
                    delId,
                    {
                        total: delTasks.length,
                        done: delTasks.filter(t => t.status === TASK_STATUS.DONE).length
                    }
                ])
            )
        };
    }

    // Assign multiple tasks
    async assignTasks(assignments) {
        const results = [];
        
        for (const { taskId, assignee } of assignments) {
            const parsed = await this.manifest.parseManifest();
            const task = parsed?.tasks.find(t => t.id === taskId);
            
            if (task) {
                await this.manifest.addTask(
                    taskId,
                    task.task,
                    task.deliverable,
                    assignee,
                    task.status,
                    task.priority
                );
                results.push({ taskId, assignee, success: true });
            } else {
                results.push({ taskId, assignee, success: false, error: 'Task not found' });
            }
        }

        return {
            success: results.every(r => r.success),
            results
        };
    }

    // Bulk update task priorities
    async reprioritizeTasks(priorities) {
        const results = [];
        
        for (const { taskId, priority } of priorities) {
            const parsed = await this.manifest.parseManifest();
            const task = parsed?.tasks.find(t => t.id === taskId);
            
            if (task) {
                await this.manifest.addTask(
                    taskId,
                    task.task,
                    task.deliverable,
                    task.assignee,
                    task.status,
                    priority
                );
                results.push({ taskId, priority, success: true });
            } else {
                results.push({ taskId, priority, success: false, error: 'Task not found' });
            }
        }

        return {
            success: results.every(r => r.success),
            results
        };
    }
}
