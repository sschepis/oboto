import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { exec, execFile } from 'child_process';
import util from 'util';

const execAsync = util.promisify(exec);
const execFileAsync = util.promisify(execFile);
const __dirname = path.dirname(fileURLToPath(import.meta.url));

export class SkillsManager {
    constructor(workspaceRoot) {
        this.workspaceRoot = workspaceRoot;
        // Global skills are located in the application root/skills directory
        this.globalSkillsDir = path.resolve(__dirname, '../../skills');
        // Workspace specific skills are in the workspace root/.skills directory
        this.workspaceSkillsDir = path.join(workspaceRoot, '.skills');
        
        this.skills = new Map(); // name -> { metadata, content, path, source: 'global'|'workspace'|'npm' }
        this.initialized = false;
    }

    async ensureInitialized() {
        if (this.initialized) return;
        await this.loadSkills();
        this.initialized = true;
    }

    async loadSkills() {
        this.skills.clear();
        
        // Load global skills first
        await this.loadSkillsFromDir(this.globalSkillsDir, 'global');

        // Load workspace skills (can override global skills)
        await this.loadSkillsFromDir(this.workspaceSkillsDir, 'workspace');

        // Load npm skills (from package.json)
        await this.loadNpmSkills();
    }

    async loadNpmSkills() {
        try {
            const packageJsonPath = path.join(this.workspaceRoot, 'package.json');
            try {
                await fs.access(packageJsonPath);
            } catch {
                return; // No package.json, so no npm skills
            }

            const content = await fs.readFile(packageJsonPath, 'utf8');
            let packageJson;
            try {
                packageJson = JSON.parse(content);
            } catch (e) {
                console.error(`Error parsing package.json: ${e.message}`);
                return;
            }

            const dependencies = { 
                ...(packageJson.dependencies || {}), 
                ...(packageJson.devDependencies || {}) 
            };

            for (const pkgName of Object.keys(dependencies)) {
                // Try to find README in node_modules
                const possiblePaths = [
                    path.join(this.workspaceRoot, 'node_modules', pkgName, 'README.md'),
                    path.join(this.workspaceRoot, 'node_modules', pkgName, 'readme.md'),
                    path.join(this.workspaceRoot, 'node_modules', pkgName, 'README.txt'),
                    path.join(this.workspaceRoot, 'node_modules', pkgName, 'README'),
                ];

                let readmeContent = `NPM Package: ${pkgName}\n\nNo documentation found (README missing).`;
                let skillPath = path.join(this.workspaceRoot, 'node_modules', pkgName);
                
                for (const p of possiblePaths) {
                    try {
                        const content = await fs.readFile(p, 'utf8');
                        readmeContent = content;
                        skillPath = p; // Use the readme path if found
                        break;
                    } catch {}
                }

                // Register as skill
                // We prefer manual skills (global/workspace) over npm skills if names collide?
                // Or maybe npm skills override? 
                // Let's assume manual skills override npm skills to allow wrapping them.
                if (!this.skills.has(pkgName)) {
                    this.skills.set(pkgName, {
                        name: pkgName,
                        description: `NPM Package: ${pkgName}`,
                        metadata: { type: 'npm', version: dependencies[pkgName] },
                        content: readmeContent,
                        path: skillPath,
                        source: 'npm'
                    });
                }
            }
        } catch (error) {
            console.error(`Failed to load npm skills: ${error.message}`);
        }
    }

    async addNpmSkills(packages) {
        if (!packages || packages.length === 0) return "No packages specified.";
        
        const packageJsonPath = path.join(this.workspaceRoot, 'package.json');
        
        // Ensure package.json exists
        try {
            await fs.access(packageJsonPath);
        } catch {
            await fs.writeFile(packageJsonPath, JSON.stringify({
                name: "workspace-skills",
                version: "1.0.0",
                description: "Auto-generated by AI Assistant for npm skills",
                dependencies: {}
            }, null, 2));
        }

        // Install packages â€” use execFile to avoid shell injection via crafted package names
        try {
             await execFileAsync('npm', ['install', ...packages], { cwd: this.workspaceRoot });
        } catch (error) {
            throw new Error(`Failed to install packages (${packages.join(', ')}): ${error.message}`);
        }

        // Reload skills to pick up new ones
        await this.loadNpmSkills();
        
        return `Successfully installed and registered skills: ${packages.join(', ')}`;
    }

    async loadSkillsFromDir(directory, source) {
        try {
            // Check if directory exists
            try {
                await fs.access(directory);
            } catch {
                return; // No skills dir, that's fine
            }

            // Scan directory
            // Supports:
            // dir/my-skill.md
            // dir/my-skill/SKILL.md
            
            const entries = await fs.readdir(directory, { withFileTypes: true });
            
            for (const entry of entries) {
                let skillPath = null;
                
                if (entry.isDirectory()) {
                    // Check for SKILL.md inside
                    const subPath = path.join(directory, entry.name, 'SKILL.md');
                    try {
                        await fs.access(subPath);
                        skillPath = subPath;
                    } catch {
                        // Ignore directories without SKILL.md
                    }
                } else if (entry.isFile() && entry.name.endsWith('.md')) {
                    skillPath = path.join(directory, entry.name);
                }

                if (skillPath) {
                    await this.parseSkill(skillPath, source);
                }
            }
        } catch (error) {
            console.error(`Failed to load skills from ${directory}: ${error.message}`);
        }
    }

    async parseSkill(filePath, source) {
        try {
            const content = await fs.readFile(filePath, 'utf8');
            const { metadata, body } = this.extractFrontmatter(content);
            
            const name = metadata.name || path.basename(path.dirname(filePath));
            
            this.skills.set(name, {
                name,
                description: metadata.description || '',
                metadata,
                content: body,
                path: filePath,
                source
            });
        } catch (error) {
            console.error(`Error parsing skill at ${filePath}: ${error.message}`);
        }
    }

    // Simple frontmatter parser
    extractFrontmatter(content) {
        const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
        if (match) {
            const yaml = match[1];
            const body = match[2];
            const metadata = this.parseYaml(yaml);
            return { metadata, body };
        }
        return { metadata: {}, body: content };
    }

    // Very basic YAML parser (sufficient for simple skill metadata)
    // For robust parsing, we'd need 'js-yaml', but trying to avoid deps if possible.
    // If complex nested structures are used, this might break.
    // Given the example, it uses nested objects.
    // Let's implement a slightly better one or just use a regex for key fields.
    parseYaml(yaml) {
        const result = {};
        const lines = yaml.split('\n');
        
        // Simple key: value parser
        for (const line of lines) {
            const keyMatch = line.match(/^([a-zA-Z0-9_-]+):\s*(.*)$/);
            if (keyMatch) {
                const key = keyMatch[1];
                let value = keyMatch[2].trim();
                
                // Remove quotes
                if (value.startsWith('"') && value.endsWith('"')) value = value.slice(1, -1);
                if (value.startsWith("'") && value.endsWith("'")) value = value.slice(1, -1);
                
                result[key] = value;
            }
        }
        return result;
    }

    listSkills() {
        return Array.from(this.skills.values()).map(s => ({
            name: s.name,
            description: s.description,
            source: s.source
        }));
    }

    getSkill(name) {
        return this.skills.get(name);
    }
    
    getSkillsSummary() {
        const skills = this.listSkills();
        if (skills.length === 0) return "";
        
        return "AVAILABLE SKILLS (Use 'read_skill' to view instructions):\n" + 
               skills.map(s => `- ${s.name} [${s.source}]: ${s.description}`).join('\n');
    }

    /**
     * Search ClawHub registry for skills.
     * Shells out to the `clawdhub` CLI.
     * @param {string} query - Search query
     * @returns {Promise<Array<{slug: string, name: string, description: string, version: string, emoji?: string}>>}
     */
    async searchClawHub(query) {
        // Check if clawdhub CLI is available
        try {
            await execAsync('which clawdhub');
        } catch {
            throw new Error('ClawHub CLI (clawdhub) is not installed. Run: npm install -g clawdhub');
        }

        try {
            const { stdout } = await execFileAsync('clawdhub', ['search', query, '--json'], {
                timeout: 30000
            });
            const results = JSON.parse(stdout);
            // Cross-reference with installed skills
            const installed = this.listSkills();
            const installedNames = new Set(installed.map(s => s.name));
            return (Array.isArray(results) ? results : []).map(r => ({
                slug: r.slug || r.name,
                name: r.name || r.slug,
                description: r.description || '',
                version: r.version || '',
                emoji: r.emoji || '',
                installed: installedNames.has(r.slug || r.name)
            }));
        } catch (error) {
            if (error.message.includes('not installed')) throw error;
            throw new Error(`ClawHub search failed: ${error.message}`);
        }
    }

    /**
     * Install a skill from ClawHub into the global skills directory.
     * @param {string} slug - Skill slug to install
     * @param {string} [version] - Optional version
     * @returns {Promise<string>} Success message
     */
    async installFromClawHub(slug, version) {
        try {
            await execAsync('which clawdhub');
        } catch {
            throw new Error('ClawHub CLI (clawdhub) is not installed. Run: npm install -g clawdhub');
        }

        try {
            const args = ['install', slug];
            if (version) args.push('--version', version);
            args.push('--workdir', this.globalSkillsDir, '--dir', this.globalSkillsDir);
            await execFileAsync('clawdhub', args, { timeout: 60000 });
        } catch (error) {
            throw new Error(`Failed to install skill '${slug}' from ClawHub: ${error.message}`);
        }

        // Reload skills to pick up the new one
        await this.loadSkills();
        this.initialized = true;
        return `Successfully installed skill '${slug}' from ClawHub`;
    }

    /**
     * Install an npm package globally and register it as a global skill.
     * @param {string} packageName - npm package name
     * @returns {Promise<string>} Success message
     */
    async installNpmGlobal(packageName) {
        // Validate npm package name format to prevent path traversal
        if (!/^(@[a-z0-9-~][a-z0-9-._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/.test(packageName)) {
            throw new Error(`Invalid npm package name: '${packageName}'`);
        }
        // Install globally
        try {
            await execFileAsync('npm', ['install', '-g', packageName], { timeout: 120000 });
        } catch (error) {
            throw new Error(`Failed to install npm package '${packageName}': ${error.message}`);
        }

        // Find the global package location
        let globalPrefix;
        try {
            const { stdout } = await execAsync('npm prefix -g');
            globalPrefix = stdout.trim();
        } catch {
            globalPrefix = '/usr/local';
        }

        const pkgDir = path.join(globalPrefix, 'lib', 'node_modules', packageName);
        
        // Look for SKILL.md in the package
        const skillMdPaths = [
            path.join(pkgDir, 'SKILL.md'),
            path.join(pkgDir, 'skill.md'),
            path.join(pkgDir, 'skills', 'SKILL.md'),
        ];

        let skillContent = null;
        for (const p of skillMdPaths) {
            try {
                skillContent = await fs.readFile(p, 'utf8');
                break;
            } catch {}
        }

        // If no SKILL.md found, try README.md as fallback
        if (!skillContent) {
            const readmePaths = [
                path.join(pkgDir, 'README.md'),
                path.join(pkgDir, 'readme.md'),
            ];
            for (const p of readmePaths) {
                try {
                    skillContent = await fs.readFile(p, 'utf8');
                    // Wrap README content with minimal frontmatter if it doesn't have any
                    if (!skillContent.startsWith('---')) {
                        skillContent = `---\nname: ${packageName}\ndescription: "NPM package: ${packageName}"\nsource: npm\n---\n\n${skillContent}`;
                    }
                    break;
                } catch {}
            }
        }

        if (!skillContent) {
            skillContent = `---\nname: ${packageName}\ndescription: "NPM package: ${packageName} (no documentation found)"\nsource: npm\n---\n\n# ${packageName}\n\nGlobally installed npm package. No SKILL.md or README.md found.`;
        }

        // Write the skill into the global skills directory
        const skillDir = path.join(this.globalSkillsDir, packageName);
        await fs.mkdir(skillDir, { recursive: true });
        await fs.writeFile(path.join(skillDir, 'SKILL.md'), skillContent, 'utf8');
        
        // Write a marker file so we know this is an npm-sourced skill
        await fs.writeFile(
            path.join(skillDir, '.npm-source.json'),
            JSON.stringify({ packageName, installedAt: new Date().toISOString() }, null, 2),
            'utf8'
        );

        // Reload skills
        await this.loadSkills();
        this.initialized = true;
        return `Successfully installed npm package '${packageName}' as a global skill`;
    }

    /**
     * Create a new skill from content.
     * @param {string} name - Skill name (used as directory name)
     * @param {string} content - Full SKILL.md content (including optional frontmatter)
     * @param {'workspace'|'global'} [scope='workspace'] - Where to create the skill
     * @returns {Promise<string>} Success message
     */
    async createSkill(name, content, scope = 'workspace') {
        await this.ensureInitialized();

        // Validate name: alphanumeric + hyphens only
        if (!/^[a-zA-Z0-9][a-zA-Z0-9_-]*$/.test(name)) {
            throw new Error(`Invalid skill name '${name}'. Use alphanumeric characters, hyphens, and underscores only.`);
        }

        // Check for collision
        if (this.skills.has(name)) {
            throw new Error(`Skill '${name}' already exists (source: ${this.skills.get(name).source}). Use edit_skill to modify it, or delete_skill first.`);
        }

        const baseDir = scope === 'global' ? this.globalSkillsDir : this.workspaceSkillsDir;
        const skillDir = path.join(baseDir, name);
        const skillPath = path.join(skillDir, 'SKILL.md');

        // Ensure the content has frontmatter with at least a name
        let finalContent = content;
        if (!content.trimStart().startsWith('---')) {
            finalContent = `---\nname: ${name}\n---\n\n${content}`;
        }

        await fs.mkdir(skillDir, { recursive: true });
        await fs.writeFile(skillPath, finalContent, 'utf8');

        // Reload to pick up the new skill
        await this.loadSkills();
        this.initialized = true;

        return `Created skill '${name}' at ${skillPath}`;
    }

    /**
     * Edit an existing skill's content (full replacement).
     * @param {string} name - Skill name
     * @param {string} content - New SKILL.md content
     * @returns {Promise<string>} Success message
     */
    async editSkill(name, content) {
        await this.ensureInitialized();

        const skill = this.skills.get(name);
        if (!skill) {
            throw new Error(`Skill '${name}' not found. Use list_skills to see available skills.`);
        }

        if (skill.source === 'npm') {
            throw new Error(`Cannot edit npm skill '${name}'. npm skills are derived from installed packages.`);
        }

        // Ensure the content has frontmatter with at least a name
        let finalContent = content;
        if (!content.trimStart().startsWith('---')) {
            finalContent = `---\nname: ${name}\n---\n\n${content}`;
        }

        await fs.writeFile(skill.path, finalContent, 'utf8');

        // Reload to pick up changes
        await this.loadSkills();
        this.initialized = true;

        return `Updated skill '${name}' at ${skill.path}`;
    }

    /**
     * Delete a skill by name.
     * @param {string} name - Skill name to delete
     * @returns {Promise<string>} Success message
     */
    async deleteSkill(name) {
        await this.ensureInitialized();
        const skill = this.skills.get(name);

        if (!skill) {
            throw new Error(`Skill '${name}' not found`);
        }

        if (skill.source === 'npm') {
            throw new Error(`Cannot delete npm skill '${name}'. Uninstall the npm package instead.`);
        }

        let skillDir;
        let isSingleFile = false;
        const baseDir = skill.source === 'global' ? this.globalSkillsDir : this.workspaceSkillsDir;

        if (skill.path) {
            skillDir = path.dirname(skill.path);
            // Single file skill (e.g., skills/my-skill.md)
            if (skillDir === baseDir && skill.path.endsWith('.md')) {
                isSingleFile = true;
                skillDir = skill.path;
            }
        } else {
            skillDir = path.join(baseDir, name);
        }

        // Defense-in-depth: ensure the resolved path is strictly inside the expected base directory
        // (never allow deleting the base directory itself)
        const resolvedTarget = path.resolve(skillDir);
        const resolvedBase = path.resolve(baseDir);
        if (!resolvedTarget.startsWith(resolvedBase + path.sep)) {
            throw new Error(`Refusing to delete '${name}': resolved path ${resolvedTarget} is outside ${resolvedBase}`);
        }

        if (isSingleFile) {
            await fs.unlink(skillDir);
        } else {
            await fs.rm(skillDir, { recursive: true, force: true });
        }

        this.skills.delete(name);
        return `Deleted skill '${name}'`;
    }

    /**
     * Uninstall a skill by name. Removes it from the global skills directory.
     * @param {string} name - Skill name to uninstall
     * @returns {Promise<string>} Success message
     */
    async uninstallSkill(name) {
        await this.ensureInitialized();
        const skill = this.skills.get(name);

        if (!skill) {
            throw new Error(`Skill '${name}' not found`);
        }

        // Only allow uninstalling global skills (not workspace skills)
        if (skill.source === 'workspace') {
            throw new Error(`Cannot uninstall workspace skill '${name}' from settings. Remove it from the .skills/ directory manually.`);
        }

        let skillDir;
        let isSingleFile = false;

        if (skill.path) {
            // skill.path points to the SKILL.md file, get the directory
            skillDir = path.dirname(skill.path);
            
            // Check if the path is directly inside globalSkillsDir (e.g., skills/my-skill.md)
            if (skillDir === this.globalSkillsDir && skill.path.endsWith('.md')) {
                isSingleFile = true;
                // For single file skills, we need to be careful not to delete the whole skills dir
                skillDir = skill.path; 
            }
        } else {
            // Fallback assumption: it's a directory in global skills
            skillDir = path.join(this.globalSkillsDir, name);
        }

        // Check if this was an npm-sourced skill (only applicable if it's a directory)
        if (!isSingleFile) {
             try {
                const npmSourcePath = path.join(skillDir, '.npm-source.json');
                const npmSourceContent = await fs.readFile(npmSourcePath, 'utf8');
                const npmSource = JSON.parse(npmSourceContent);
                
                if (npmSource.packageName) {
                    try {
                        // Uninstall globally
                        await execFileAsync('npm', ['uninstall', '-g', npmSource.packageName], { timeout: 30000 });
                    } catch (e) {
                        console.error(`Warning: npm uninstall -g ${npmSource.packageName} failed: ${e.message}`);
                    }
                }
            } catch (e) {
                // Not an npm-sourced skill or file not found, which is fine
            }
        }

        // Remove the skill
        if (isSingleFile) {
            await fs.unlink(skillDir); // skillDir is the file path here
        } else {
            await fs.rm(skillDir, { recursive: true, force: true });
        }
        
        this.skills.delete(name);
        return `Uninstalled skill '${name}'`;
    }

    /**
     * Check if ClawHub CLI is available.
     * @returns {Promise<boolean>}
     */
    async isClawHubAvailable() {
        try {
            await execAsync('which clawdhub');
            return true;
        } catch {
            return false;
        }
    }
}
